# GC回收机制

unity采用的**boehm-demers-weiser（BWD）**垃圾回收算法，这是一种基于指针追踪的垃圾回收算法

BDW 算法的基本思想是**通过追踪内存中对象之间的指针关系来确定哪些对象是活动的，哪些对象是垃圾**。为此，BDW 算法维护了一个指针表，记录了内存中所有指针的位置和指向的对象，然后从根对象开始遍历指针表中的所有指针，依次标记所有可达的对象为活动对象，未标记的对象则被认为是垃圾对象，可以被回收内存。

BDW 算法的另一个特点是它采用了**分代存储**的策略，将内存分为多个代，每个代包含不同年龄的对象，年龄越大的对象越难以成为垃圾，因此可以采用更少的垃圾回收时间来回收它们。BDW 算法中的垃圾回收操作包括标记、清除和整理三个步骤，其中标记阶段用于标记活动对象，清除阶段用于清除垃圾对象，整理阶段用于压缩内存碎片，以提高内存利用效率。

**分代存储：**

在 Unity 引擎中，分代存储被广泛应用于垃圾回收机制中，以提高垃圾回收效率和游戏性能。

Unity 引擎将内存分为三个代，分别是

新生代（Young Generation）、

持久代（Persistent Generation）

和永久代（Permanent Generation）。

**新生代**存储的是刚刚创建的对象，这些对象的生命周期很短，通常只存活几个帧，因此采用了 Boehm-Demers-Weiser （BDW）算法中的**复制算法**，即将新生代内存分为两个相等的部分，每次只使用其中一部分，当这部分内存用尽时，将存活的对象复制到另一部分中，然后清空原来的部分，以保证新生代内存的可用性和回收效率。

**持久代**存储的是从新生代中存活下来的对象，这些对象的生命周期比新生代的对象长，但也不是很长，通常存活几百到几千帧。持久代采用了**标记-整理算法**，即在垃圾回收时，首先标记出所有存活的对象，然后将它们整理到一起，以减少内存碎片和提高内存利用率。

**永久代**存储的是长时间存活的对象，这些对象的生命周期很长，甚至可能存活于整个应用程序的生命周期中。永久代采用了**标记-清除算法**，即在垃圾回收时，首先标记出所有存活的对象，然后清除所有未标记的对象，以保证内存的可用性。

**复制算法：**

在 Unity 引擎中，新生代对象使用了复制算法进行垃圾回收。具体来说，Unity 将新生代内存分为两个相等的部分，称为"From Space"和"To Space"。在开始垃圾回收之前，所有的活动对象都存储在 From Space 区域中。垃圾回收器会遍历 From Space 中的所有对象，将所有活动对象复制到 To Space 区域中，并将 From Space 区域中的所有对象视为垃圾对象。这样，To Space 区域中就存储了所有的活动对象，而 From Space 区域中就可以被清空，以便下一次垃圾回收使用。

Unity 引擎的复制算法采用了Boehm-Demers-Weiser（BDW）算法，它是一种高效的垃圾回收算法，可以在短时间内回收大量的垃圾对象。BDW算法的特点是采用了局部分配器、分代垃圾回收和复制算法等多种技术，以提高垃圾回收效率和内存利用率。

复制算法的优点是简单、高效、容易实现和维护，并且可以避免内存碎片的产生，以提高内存利用率。但是，它需要两倍的内存空间来存储数据，并且需要频繁地复制数据，这可能会导致性能问题。因此，复制算法通常用于处理新生代对象，而老年代对象则采用其他的垃圾回收算法，如标记-清除算法、标记-整理算法等。

**标记-整理算法：**

标记-整理算法是一种垃圾回收算法，用于回收持久代中的垃圾对象。其基本思想是遍历内存中的所有对象，标记出所有存活的对象，然后将它们整理到一起，以减少内存碎片和提高内存利用率。

具体来说，标记-整理算法将内存分为两个区域，分别为 From Space 和 To Space。在垃圾回收之前，所有的活动对象都存储在 From Space 区域中。垃圾回收器会遍历 From Space 中的所有对象，将所有活动对象复制到 To Space 区域中，并将 From Space 区域中的所有对象视为垃圾对象。然后，垃圾回收器会将所有存活的对象从 To Space 区域复制回 From Space 区域，以便下一轮垃圾回收使用。这个过程会导致 To Space 区域中的所有对象被整理到一起，以减少内存碎片和提高内存利用率。

标记-整理算法的优点是可以减少内存碎片，提高内存利用率，并且可以在一定程度上避免内存泄漏的问题。但是，它需要两倍的内存空间来存储数据，并且需要频繁地复制数据，这可能会导致性能问题。

**标记-清除算法**

标记-清除算法是一种垃圾回收算法，用于回收永久代中的垃圾对象。其基本思想是遍历内存中的所有对象，标记出所有存活的对象，然后清除所有未标记的对象，以保证内存的可用性。

具体来说，标记-清除算法将内存分为两个部分，分别为活动对象区域和垃圾对象区域。在垃圾回收之前，所有的活动对象都存储在活动对象区域中。垃圾回收器会遍历内存中的所有对象，标记出所有存活的对象，并将这些对象从垃圾对象区域中移动到活动对象区域中。然后，垃圾回收器会清除垃圾对象区域中的所有未标记对象，以保证内存的可用性。

标记-清除算法的优点是可以避免复制数据的开销，并且可以处理长时间存活的对象，如永久代中的对象。但是，它可能会导致内存碎片的产生，从而降低内存利用率，并且可能会导致性能问题。

**怎么解决标记-清除算法导致内存碎片的产生**

**增量式标记-清除算法**可以将标记-清除算法的标记和清除过程分解为多个阶段，并在每个阶段中交替执行标记和清除操作。这样可以将整个垃圾回收过程分解为多个小的任务，每个任务只占用一小部分时间，从而避免了在一次完整的垃圾回收操作中暂停应用程序的问题。

具体来说，增量式标记-清除算法将垃圾回收过程分解为三个阶段，分别为：

1. 标记阶段：将所有活动对象标记为存活对象，并将它们添加到一个“待清除”列表中。
2. 增量式清除阶段：将“待清除”列表中的对象分批清除，每次清除一小部分对象，并在每次清除后暂停应用程序一小段时间，以便应用程序有时间处理用户输入和其他事件。
3. 整理阶段：将所有存活对象整理到内存的一端，并将所有垃圾对象整理到另一端，以减少内存碎片和提高内存利用率。

在增量式标记-清除算法中，整理阶段是解决内存碎片问题的关键。通过将存活对象整理到内存的一端，可以将空闲内存区域整合到一起，从而减少内存碎片的产生。同时，通过将垃圾对象整理到另一端，可以将它们占用的内存空间释放出来，以便应用程序后续的内存分配使用。

需要注意的是，增量式标记-清除算法并不能完全避免内存碎片的产生，但是它可以将内存碎片的影响降到最低。在实际使用中，为了进一步提高内存利用率和性能，Unity 引擎还可以采用其他的垃圾回收算法，如标记-整理算法和复制算法等。

**怎么设置每个代的大小**

在 Unity 引擎中，可以通过命令行参数或配置文件来设置每个代的大小。具体来说，可以通过以下两种方式来设置每个代的大小：

1. 命令行参数：在启动 Unity 引擎时，可以通过命令行参数来设置每个代的大小。例如，可以使用以下命令来设置新生代的大小为 512MB，持久代的大小为 1GB：

```
Unity.exe -Xmx512m -XX:NewSize=512m -XX:MaxNewSize=512m -XX:PermSize=1g -XX:MaxPermSize=1g

```

其中，`-Xmx` 参数用于设置最大堆内存大小，`-XX:NewSize` 参数用于设置新生代初始大小，`-XX:MaxNewSize` 参数用于设置新生代最大大小，`-XX:PermSize` 参数用于设置持久代初始大小，`-XX:MaxPermSize` 参数用于设置持久代最大大小。

需要注意的是，不同版本的 Unity 引擎可能会支持不同的命令行参数，需要根据实际情况来选择。

1. 配置文件：在 Unity 引擎的安装目录中，可以找到一个名为 `unity.ini` 的文件，该文件包含了 Unity 引擎的默认配置信息。可以通过修改 `unity.ini` 文件来设置每个代的大小。具体来说，可以找到以下几个配置项：

```
-MaxHeapSize
-NewHeapSize
-MaxNewHeapSize
-PermHeapSize
-MaxPermHeapSize

```

分别对应最大堆内存大小、新生代初始大小、新生代最大大小、持久代初始大小和持久代最大大小。可以修改这些配置项来设置每个代的大小。需要注意的是，修改 `unity.ini` 文件可能会影响 Unity 引擎的其他配置信息，因此需要谨慎操作。

需要根据应用程序的实际情况来设置每个代的大小，以达到垃圾回收的最佳效果。一般来说，可以根据应用程序的内存使用情况来设置每个代的大小，使得每个代的内存空间充分利用，同时又不会过度占用系统资源。

**unity的分代算法什么时候切换到下一代**

Unity 引擎的垃圾回收器采用了分代垃圾回收算法，将内存分为三个代：新生代、老年代和持久代。

新生代用于存储短时间内产生的对象，这些对象的生命周期很短，大部分对象很快就会变成垃圾对象。新生代采用了复制算法进行垃圾回收，当新生代中的对象达到一定数量时，垃圾回收器会对其进行一次垃圾回收操作，并将存活的对象复制到老年代中。

老年代用于存储生命周期较长的对象，这些对象的生命周期比较长，但不是永久性的。老年代采用了标记-整理算法进行垃圾回收，当老年代中的对象达到一定数量时，垃圾回收器会对其进行一次垃圾回收操作，并将存活的对象复制到持久代中。

持久代用于存储永久性的对象，这些对象的生命周期很长，甚至可以存活整个应用程序的生命周期。持久代采用了标记-清除算法进行垃圾回收，当持久代中的对象达到一定数量时，垃圾回收器会对其进行一次垃圾回收操作。

Unity 引擎的分代切换是自动进行的，当一个代中的对象达到一定数量时，垃圾回收器就会对其进行垃圾回收操作，并将存活的对象复制到下一个代中。具体来说，新生代中的对象达到一定数量时，会触发一次新生代垃圾回收操作，并将存活的对象复制到老年代中。老年代中的对象达到一定数量时，会触发一次老年代垃圾回收操作，并将存活的对象复制到持久代中。

需要注意的是，分代切换的具体策略可能因 Unity 引擎的版本而有所不同，需要根据实际情况进行调整和优化。